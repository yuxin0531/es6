<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        //name 属性
        function foo() {
            console.log(foo.name);
            //'foo'
        }
        foo()

        // 这个属性早就被浏览器广泛支持，但是直到 ES6，才将其写入了标准。
        // 需要注意的是，ES6 对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，
        // ES5 的name属性，会返回空字符串，而 ES6 的name属性会返回实际的函数名s
        var f = function () { };
        // ES5
        console.log(f.name);//""
        //ES6
        console.log(f.name);//"f"
        // 上面代码中，变量f等于一个匿名函数，ES5 和 ES6 的name属性返回的值不一样。


        // 如果将一个具名函数赋值给一个变量，则 ES5 和 ES6 的name属性都返回这个具名函数原本的名字。
        const bar = function baz() { };
        //ES5
        console.log(bar.name);//"baz"
        //ES6
        console.log(bar.name);//baz

        // Function构造函数返回的函数实例，name属性的值为anonymous(翻译:匿名的，无名的；无个性特征的)。
        (new Function).name //"anonymous"

            // bind返回的函数，name属性值会加上bound前缀。不懂
            (function () { }).bind({}).name // "bound " 一定会；很可能会；必定的；受约束的，有义务的；因……受阻；被……所
            
        // bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。
        // 例子:
        // this.x = 9;    // 在浏览器中，this 指向全局的 "window" 对象
        // var module = {
        //     x: 81,
        //     getX: function () { return this.x; }
        // };

        // module.getX(); // 81

        // var retrieveX = module.getX;
        // retrieveX();
        // // 返回 9 - 因为函数是在全局作用域中调用的

        // // 创建一个新函数，把 'this' 绑定到 module 对象
        // // 新手可能会将全局变量 x 与 module 的属性 x 混淆
        // var boundGetX = retrieveX.bind(module);
        // boundGetX(); // 81
        // 参考链接:https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind
    </script>
</body>

</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        // Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与proxy handlers的方法相同。Reflect不是一个函数对象，因此它是不可构造的。
        // 描述
        // 与大多数全局对象不同，Reflect不是一个构造函数。你不能将其与一个new运算符一起使用，或者将Reflect对象作为一个函数来调用。Reflect的所有属性和方法都是静态的（就像Math对象）。

        // 方法
        // Reflect对象提供以下静态函数，它们具有与处理器对象方法相同的名称。这些方法中的一些与 Object 上的对应方法相同。
        Reflect.apply()
        // 对一个函数进行调用操作,同时可以传入一个数组作为调用参数,和Function.prototpe.apply()功能类似.

        Reflect.construct()
        // 对构造函数进行new操作，相当于执行new target(...args).

        Reflect,deleteProperty()
        // 作为函数delete操作,相当于执行delete target[name]

        Reflect.enumerate()
        // 该方法会返回一个包含目标对象身上所有可枚举的自身字符串属性以及继承字符串属性的迭代器,for...in操作遍历到的正是这些属性

        Reflect.get()
        // 获取对象身上某个属性的值,类似于target[name].

        Reflect.getOwnPropertyDescriptor()
        // 类似于Object.getOwnPropertyDescriptor

        Reflect.getPrototypeOf()
        // 类似于Object.getPrototypeOf().getPrototypeOf

        Reflect.has()
        // 判断一个对象是否存在某个属性,和in运算的功能完全相同.

        Reflect.isExtensible()
        // 类似于Object.isExtensible()

        Reflect.ownKeys()
        // 返回一个包含所有自身属性(不包含继承属性)的数组,(类似于Object.keys()).但不会受enumerable影响

        Reflect.preventExtensions()
        // 类似于Oject.preventExtensions().返回一个Boolean.

        Reflect.set()
        // 将值分配给属性的函数，返回一个Boolean。如果更新成功，则返回他true

        Reflect.setPrototypeOf()
        // 类似于Object.setPrototypeOf().
        // 参考:https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。
        // 例子:
        this.x = 9;    // 在浏览器中，this 指向全局的 "window" 对象
        var module = {
            x: 81,
            getX: function () { return this.x; }
        };

        module.getX(); // 81

        var retrieveX = module.getX;
        retrieveX();
        // 返回 9 - 因为函数是在全局作用域中调用的

        // 创建一个新函数，把 'this' 绑定到 module 对象
        // 新手可能会将全局变量 x 与 module 的属性 x 混淆
        var boundGetX = retrieveX.bind(module);
        boundGetX(); // 81
        // !!!fn.bind(null,x1,x2..)null只是代表这个参数是空,不会改变其原本的this指向,这样写的功能只是为这个函数预设了x1,x2的默认值
        // 参考链接:https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind

        // call和apply作用是一样的，都是为了改变某个函数运行时的上下文（context）而存在的，换句话说，就是为了改变函数体内部this的指向。
        // call,apply例子 call() 方法可接受参数：
        // 下面例子使用person的方法来调用person1的属性
        // call() 方法分别接受参数。
        // function.call(thisArg, arg1, arg2, ...)
        // apply() 方法接受数组形式的参数。
        // 用 apply 将数组添加到另一个数组
        // var array = ['a', 'b'];
        // var elements = [0, 1, 2];
        // array.push.apply(array, elements);
        // console.info(array); // ["a", "b", 0, 1, 2]
        // 使用apply接收一个数组让函数接收一个数组参数
        // function f(x,y,z){
        //    console.log(x+y+z);//3
        // }
        // var args = [0,1,2];
        // f.apply(null,args);
    </script>
</body>

</html>
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        //默认值
        let [foo =true] =[];
        console.log(foo);//true 这里开始就设定了默认值foo=true,如果赋值为空就为使用默认值,如果赋值不为空则使用赋值
        let [x,y='b'] =['a']
        console.log(x);//a
        console.log(y);//b 
        // 这里x的赋值有值a所以使用a赋值给x,而y没有可以赋值,所有使用,默认值b
        let [x, y = 'b'] = ['a', undefined]; // x='a', y='b'所赋的值为undefined与没有值相同

        let [x= 1] = [undefined];
        console.log(x);//1
        let [y=1] =[null];
        console.log(y);
        // 注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。
        // 如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。

        // 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。   
        function f() {
            console.log('aaa');
        }
        let [x = f()] = [1];
        // // 上面代码中，因为x能取到值，所以函数f根本不会执行。上面的代码其实等价于下面的代码。
        let x;
        if ([1][0] === undefined) {
            x = f();
        } else {
            x = [1][0];
        }
        // 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。

        let [x = 1, y = x] = [];     // x=1; y=1
        let [x = 1, y = x] = [2];    // x=2; y=2
        let [x = 1, y = x] = [1, 2]; // x=1; y=2
        let [x = y, y = 1] = []; // 报错ReferenceError: y is not defined 原因:当y没有赋值时,y还未被声明就被赋值给y所有报错,只要赋值右边有值y就不会报错
    </script>
</body>

</html>
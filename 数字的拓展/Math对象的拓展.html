<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // Math 对象的扩展
        // ES6 在 Math 对象上新增了 17 个与数学相关的方法。所有这些方法都是静态方法，只能在 Math 对象上调用。

        // 1.Math.trunc()
        // Math.trunc方法用于去除一个数的小数部分，返回整数部分。

        // console.log(Math.trunc(4.19));//4
        // console.log(Math.trunc(4.9));//4
        // console.log(Math.trunc(-4.1));//-4
        // console.log(Math.trunc(-4.9));//-4
        // console.log(Math.trunc(-0.1234));//-0

        // // 对于非数值，Math.trunc内部使用Number方法将其先转为数值。
        // console.log(Math.trunc('123.456'));//123
        // console.log(Math.trunc(true));//1
        // console.log(Math.trunc(false));//0
        // console.log(Math.trunc(null));//0

        // // 对于空值和无法截取整数的值，返回NaN。
        // console.log(Math.trunc(NaN));  //NaN
        // console.log(Math.trunc('foo')); //NaN
        // console.log(Math.trunc());//NaN
        // console.log(Math.trunc(undefined));//NaN

        // // 对于没有部署这个方法的环境,可以用下面的代码模拟
        // Math.trunc = Math.trunc || function (x) {
        //     return x < 0 ? Math.ceil(x) : Math.floor(x)
        // }



        // //2.Math.sign() 
        // // Math.sign方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。

        // // 它会返回五种值:
        // // 参数为正数，返回 + 1；
        // // 参数为负数，返回 - 1；
        // // 参数为 0，返回0；
        // // 参数为 - 0，返回 - 0;
        // // 其他值，返回NaN。
        // console.log(Math.sign(-5));//-1
        // console.log(Math.sign(5));//+1
        // console.log(Math.sign(0));//+0
        // console.log(Math.sign(-0));//-0
        // console.log(Math.sign(NaN));//NaN

        // // 如果参数是非数值，会自动转为数值。对于那些无法转为数值的值，会返回NaN。
        // console.log(Math.sign(''));//0
        // console.log(Math.sign(true));//+1
        // console.log(Math.sign(false));//0
        // console.log(Math.sign(null));//0
        // console.log(Math.sign('9'));//+1
        // console.log(Math.sign('foo'));//NaN
        // console.log(Math.sign());//NaN
        // console.log(Math.sign(undefined));//NaN

        // // 对于没有部署这个方法的环境，可以用下面的代码模拟.
        // Math.sign = Math.sign || function (x) {
        //     x = +x;//convert to a number 转换成数字
        //     if (x === 0 || isNaN(x)) {
        //         return x;
        //     }
        //     return x > 0 ? 1 : -1;
        // }

        // //Math.cbrt() 
        // // Math.cbrt方法用于计算一个数的立方根。
        // console.log(Math.cbrt(-1));//-1
        // console.log(Math.cbrt(0));//0
        // console.log(Math.cbrt(1));//1
        // console.log(Math.cbrt(2)); //1.2599210498948734

        // // 对于非数值，Math.cbrt方法内部也是先使用Number方法将其转为数值。
        // console.log(Math.cbrt('8'));//2
        // console.log(Math.cbrt('hello'));//NaN

        // // 对于没有部署这个方法的环境，可以用下面的代码模拟。
        // Math.cbrt = Math.cbrt || function (x) {
        //     var y = Math.pow(Math.abs(x), 1 / 3);//Math.pow(x,y) x:必需。底数。必须是数字。 y:必需。幂数。必须是数字。
        //     return x < 0 ? -y : y;
        // }




        // 3.Math.clz32()
        // Math.clz32()方法将参数转为 32 位无符号整数的形式，然后返回这个 32 位值里面有多少个前导 0。

        // console.log(Math.clz32(0));//32
        // console.log(Math.clz32(1));//31
        // console.log(Math.clz32(1000));//22
        // console.log(Math.clz32(0b01000000000000000000000000000000));//1
        // console.log(Math.clz32(0b00100000000000000000000000000000));//2

        // 上面代码中，0 的二进制形式全为 0，所以有 32 个前导 0；1 的二进制形式是0b1，只占 1 位，
        // 所以 32 位之中有 31 个前导 0；1000 的二进制形式是0b1111101000，一共有 10 位，所以 32 位之中有 22 个前导 0。
        // clz32这个函数名就来自”count leading zero bits in 32-bit binary representation of a number
        // “（计算一个数的 32 位二进制形式的前导 0 的个数）的缩写。


        // 左移运算符（<<）与Math.clz32方法直接相关。
        //<<二进制的左移运算,例如: 5的进制00000000000000000000000000000101 (5<<2) => 20的二进制00000000000000000000000000010100 
        // console.log(Math.clz32(0));//32
        // console.log(Math.clz32(1));//31
        // console.log(Math.clz32(1 << 1));//30
        // console.log(Math.clz32(1 << 2));//29
        // console.log(Math.clz32(1 << 29));//2

        // // 对于小数，Math.clz32方法只考虑整数部分
        // console.log(Math.clz32(3.2));//30
        // console.log(Math.clz32(3.9));//30

        // // 对于空值或其他类型的值，Math.clz32方法会将它们先转为数值，然后再计算
        // console.log(Math.clz32());//32
        // console.log(Math.clz32(NaN));//32
        // console.log(Math.clz32(Infinity));//32
        // console.log(Math.clz32(null));//32
        // console.log(Math.clz32('foo'));//32
        // console.log(Math.clz32([]));//32
        // console.log(Math.clz32({}));//32
        // console.log(Math.clz32(true));//31



        // 4.Math.imul() 不懂
        // Math.imul方法返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数。

        // console.log(Math.imul(2,4)); //8
        // console.log(Math.imul(-1,8));//-8
        // console.log(Math.imul(-2,-2));//4
        // // 如果只考虑最后 32 位，大多数情况下，Math.imul(a, b)与a * b的结果是相同的，即该方法等同于(a * b)|0的效果（超过 32 位的部分溢出）。
        // // 之所以需要部署这个方法，是因为 JavaScript 有精度限制，超过 2 的 53 次方的值无法精确表示。这就是说，对于那些很大的数的乘法，
        // // 低位数值往往都是不精确的，Math.imul方法可以返回正确的低位数值。
        // console.log((0x7fffffff * 0x7fffffff)|0);//0
        // // 上面这个乘法算式，返回结果为 0。但是由于这两个二进制数的最低位都是 1，所以这个结果肯定是不正确的，因为根据二进制乘法，
        // // 计算结果的二进制最低位应该也是 1。这个错误就是因为它们的乘积超过了 2 的 53 次方，JavaScript 无法保存额外的精度，
        // // 就把低位的值都变成了 0。Math.imul方法可以返回正确的值 1。
        // console.log(Math.imul(0x7fffffff, 0x7fffffff));//1




        // 5.Math.fround() 不懂
        // Math.fround方法返回一个数的32位单精度浮点数形式。

        // 对于32位单精度格式来说，数值精度是24个二进制位（1 位隐藏位与 23 位有效位），
        // 所以对于 -224 至 224 之间的整数（不含两个端点），返回结果与参数本身一致。
        //     console.log(Math.fround(0));//0
        //     console.log(Math.fround(1));//1
        //     // !!!!**次方2**24 =>2的24次方
        //     console.log(Math.fround(2**24-1));//16777215

        //     // 如果参数的绝对值大于 2的24次方，返回的结果便开始丢失精度。
        //    console.log(Math.fround(2**24));//167772166
        //    console.log(Math.fround(2**24+1));//167772166

        //     //    Math.fround方法的主要作用，是将64位双精度浮点数转为32位单精度浮点数。
        //     //    如果小数的精度超过24个二进制位，返回值就会不同于原值，否则返回值不变（即与64位双精度值一致）。
        //     console.log(Math.fround(1.125));//1.125
        //     console.log(Math.fround(7.25));//7.25

        //     //丢失精度
        //     console.log(Math.fround(0.3));//0.30000001192092896
        //     console.log(Math.fround(0.7));//0.699999988079071
        //     console.log(Math.fround(1.0000000123));//1

        //     // 对于 NaN 和 Infinity，此方法返回原值。对于其它类型的非数值，Math.fround 方法会先将其转为数值，再返回单精度浮点数。
        //     console.log(Math.fround(NaN));//NaN
        //     console.log(Math.fround(Infinity));//Infinity
        //     console.log(Math.fround('5'));//5
        //     console.log(Math.fround(true));//1
        //     console.log(Math.fround(null));//0
        //     console.log(Math.fround([]));//0
        //     console.log(Math.fround({}));//NaN

        //     // 对于没有部署这个方法的环境，可以用下面的代码模拟。
        //     Math.fround= Math.fround || function(x){
        //         return new Float32Array([x])[0];
        //     }


        // 6.Math.hypot()
        // Math.hypot方法返回所有参数的平方和的平方根。
        // 根号里面value的平方+value2的平方.....比如Math.hypot(3,4)=>3平方+4的平方然后开方等于5 √3²+√4²=√25 = 5  
        // console.log(Math.hypot(3,4)); //5
        // // 上面代码中，3 的平方加上 4 的平方，等于 5 的平方。
        // console.log(Math.hypot(3,4,5));//7.0710678118654755
        // console.log(Math.hypot());//0
        // console.log(Math.hypot(NaN));//NaN
        // console.log(Math.hypot(3,4,'foo'));//NaN
        // // console.log(Math.hypot(3,4,'5'));/7.0710678118654755
        // console.log(Math.hypot(-3));//3
        // 如果参数不是数值，Math.hypot方法会将其转为数值。只要有一个参数无法转为数值，就会返回 NaN。

        // 对数方法
        // ES6 新增了 4 个对数相关方法。

        // 7.Math.expm1()不懂
        // Math.expm1(x)返回 ex - 1，即Math.exp(x) - 1。
        // console.log(Math.expm1(-1));//-0.6321205588285577
        // console.log(Math.expm1(0));//0
        // console.log(Math.expm1(1));//1.718281828459045
        // // 对于没有部署这个方法的环境，可以用下面的代码模拟。
        // Math.expm1 = Math.expm1 || function(x){
        //     return Math.exp(x)-1
        // }


        // // 8.Math.log1p()不懂
        // // Math.log1p(x)方法返回1 + x的自然对数，即Math.log(1 + x)。如果x小于-1，返回NaN。
        // console.log(Math.log1p(1));//0.6931471805599453
        // console.log(Math.log1p(0));//0
        // console.log(Math.log1p(-1));//-Infinity
        // console.log(Math.log1p(-2));//NaN

        // // 对于没有部署这个方法的环境，可以用下面的代码模拟。
        // Math.log1p = Math.log1p || function(x){
        //     return Math.log(1+x);
        // };



        // 9.Math.log10()
        // Math.log10(x)返回以 10 为底的x的对数。如果x小于 0，则返回 NaN。
        // 例如Math.log10(2) => 10的多少次方等于2
        // console.log(Math.log10(2));//0.3010299956639812
        // console.log(Math.log10(1));//0
        // console.log(Math.log10(0));//Infinity
        // console.log(Math.log10(-2));//NaN
        // console.log(Math.log10(100000));//5

        // // 对于没有部署这个方法的环境，可以用下面的代码模拟。
        // Math.log10 = Math.log10 || function(x){
        //     return Math.log(x) / Math.LN10;
        // }


        // 10.Math.log2()
        // Math.log2(x)返回以 2 为底的x的对数。如果x小于 0，则返回 NaN。
        // 例如Math.log2(3) = >2的多少次方等于3
        // console.log(Math.log2(3));//1.584962500721156
        // console.log(Math.log2(2));//1
        // console.log(Math.log2(1));//0
        // console.log(Math.log2(0));//-Infinity
        // console.log(Math.log2(-2));//NaN
        // console.log(Math.log2(1024));//10
        // console.log(Math.log2(1 << 29));//29

        // // 对于没有部署这个方法的环境，可以用下面的代码模拟。
        // Math.log2 = Math.log2 || function (x) {
        //     return Math.log(x) / Math.LN2;
        // }


        //11.ES6 新增了 6 个双曲函数方法。
        // Math.sinh(x) 返回x的双曲正弦（hyperbolic sine）
        // Math.cosh(x) 返回x的双曲余弦（hyperbolic cosine）
        // Math.tanh(x) 返回x的双曲正切（hyperbolic tangent）
        // Math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine）
        // Math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine）
        // Math.atanh(x) 返回x的反双曲正切（inverse hyperbolic tangent）



        // 12.指数运算符
        // ES2016 新增了一个指数运算符（**）。
        // console.log(2**2);//4
        // console.log(2**3);//8
        // // 这个运算符的一个特点是右结合，而不是常见的左结合。多个指数运算符连用时，是从最右边开始计算的。

        // console.log(2**3**2);//512
        //  // 相当于 2 ** (3 ** 2)先算3的2次方等于9,再算2的9次方
        //  //  上面代码中，首先计算的是第二个指数运算符，而不是第一个。

        // //  指数运算符可以与等号结合，形成一个新的赋值运算符（**=）
        // let a = 1.5;
        // console.log(a**=2);//2.25
        // // 等同于 a = a * a; a是1.5,2表示2次方


        // let b = 4;
        // console.log(b**=3);//64
        // //等同于b=b*v*b;b是4,3表示3次方


        // 13.BigInt 数据类型 
        // JavaScript 所有数字都保存成 64 位浮点数，这给数值的表示带来了两大限制。
        // 一是数值的精度只能到 53 个二进制位（相当于 16 个十进制位），大于这个范围的整数，
        // JavaScript 是无法精确表示的，这使得 JavaScript 不适合进行科学和金融方面的精确计算。
        // 二是大于或等于2的1024次方的数值，JavaScript 无法表示，会返回Infinity。

        // 超过 53 个二进制位的数值，无法保持精度
        // console.log(Math.pow(2, 53) === Math.pow(2, 53) + 1);//true

        // // 超过 2 的 1024 次方的数值，无法表示
        // console.log(Math.pow(2, 1024));//Infinity

        // ES2020 引入了一种新的数据类型 BigInt（大整数），来解决这个问题。
        // BigInt 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。
        // const a = 2172141653n;
        // const b = 15346349309n;

        // // BigInt 可以保持精度 chrome浏览器无法识别
        // console.log(a * b);
        // // 官方:33334444555566667777n chrome浏览器报错Invalid or unexpected token无效或意外令牌

        // // 不加n，丢失精度
        // // const a = 2172141653;
        // // const b = 15346349309;
        // // console.log(a * b);//33334444555566670000

        // // 普通整数无法保持精度
        // Number(a) * Number(b) // 33334444555566670000


        // // ！！！！为了与 Number 类型区别，BigInt 类型的数据必须添加后缀n。
        // 1234 // 普通整数
        // 1234n // BigInt

        // // BigInt 的运算
        // 1n + 2n // 3n

        // // BigInt 同样可以使用各种进制表示，都要加上后缀n。
        // 0b1101n // 二进制
        // 0o777n // 八进制
        // 0xFFn // 十六进制

        // // BigInt 与普通整数是两种值，它们之间并不相等。
        // // console.log(42n === 42 )// false

        // // typeof运算符对于 BigInt 类型的数据返回bigint。
        // console.log(typeof 123n);// 'bigint'

        // // BigInt 可以使用负号（-），但是不能使用正号（+），因为会与 asm.js 冲突。
        // -42n // 正确
        // + 42n // 报错

        // JavaScript 以前不能计算70的阶乘（即70!），因为超出了可以表示的精度。
        // let p =1;
        // for(let i = 1; i<=70; i++){
        //     p*=i;
        // }
        // console.log(p);//1.197857166996989e+100

        // 现在支持大整数了，就可以算了，浏览器的开发者工具运行下面代码，就OK。
        // let p  =1n;
        // for(let i=1;i<=70;i++){
        //     p*=i;
        // }
        // console.log(p);// 11978571...00000000n



        // 14.BigInt 对象 chrome浏览器报错 BigInt is not defined
        // JavaScript 原生提供BigInt对象，可以用作构造函数生成 BigInt 类型的数值。转换规则基本与Number()一致，将其他类型的值转为 BigInt。
        // console.log(BigInt(123));//123n
        // console.log(BigInt('123'));//123n
        // console.log(BigInt(false));//0n
        // console.log(BigInt(true));//1n
        // BigInt()构造函数必须有参数，而且参数必须可以正常转为数值，下面的用法都会报错。
        // console.log(new BigInt());// TypeError
        // console.log(BigInt(undefined));// TypeError
        // console.log(BigInt(null));// TypeError
        // console.log(BigInt('123n'));// SyntaxError
        // console.log(BigInt('abc'));// SyntaxError
        // // 上面代码中，尤其值得注意字符串123n无法解析成 Number 类型，所以会报错。

        // // 参数如果是小数，也会报错。
        // console.log(BigInt(1.5));// RangeError
        // console.log(BigInt('1.5'));//SyntaxError

        // BigInt 对象继承了 Object 对象的两个实例方法。

        // BigInt.prototype.toString()
        // BigInt.prototype.valueOf() valueOf()函数用于返回指定对象的原始值。 例如:booleanObject.valueOf()如果调用该方法的对象不是 Boolean，则抛出异常 TypeError。
        // false


        // 它还继承了 Number 对象的一个实例方法。
        // BigInt.prototype.toLocaleString() 
        // 1.arrayObject 的本地字符串表示。var arr = new Array(3)arr[0] = "George" arr[1] = "John" arr[2] = "Thomas" console.log(arr.toLocaleString())
        // George, John, Thomas
        // 2.可把本地时间转为为字符串 console.log(new Date().toLocaleString())
        // 2020/4/9 上午8:55:21

        // 此外，还提供了三个静态方法。不太懂
        // BigInt.asUintN(width, BigInt) ： 给定的 BigInt 转为 0 到 2∧width - 1 之间对应的值。
        // BigInt.asIntN(width, BigInt) ：给定的 BigInt 转为 - 2∧width ∧- 1 到 2∧width ∧- 1 - 1 之间对应的值。
        // BigInt.parseInt(string[, radix]) ：近似于Number.parseInt() ，将一个字符串转换成指定进制的 BigInt。
        // const max = 2n ** (64n - 1n) - 1n; //2的63次方-1
        // console.log(BigInt.asIntN(64, max));// 9223372036854775807n
        // console.log(BigInt.asIntN(64, max + 1n));// -9223372036854775808n
        // console.log(BigInt.asUintN(64, max + 1n));// 9223372036854775808n
        // // // 上面代码中，max是64位带符号的 BigInt 所能表示的最大值。如果对这个值加1n，
        // // // BigInt.asIntN()将会返回一个负值，因为这时新增的一位将被解释为符号位。
        // // // 而BigInt.asUintN()方法由于不存在符号位，所以可以正确返回结果。

        // // // 如果BigInt.asIntN()和BigInt.asUintN()指定的位数，小于数值本身的位数，那么头部的位将被舍弃。
        // const max = 2n ** (64n - 1n) - 1n;
        // console.log(BigInt.asIntN(32, max));//-1n   
        // console.log(BigInt.asUintN(32, max));// 4294967295n
        // // 上面代码中，max是一个64位的 BigInt，如果转为32位，前面的32位都会被舍弃。

        // // 下面是BigInt.parseInt()的例子。
        // // Number.parseInt() 与 BigInt.parseInt() 的对比
        // console.log(Number.parseInt('9007199254740993', 10));// 9007199254740992
        // console.log(BigInt.parseInt('9007199254740993', 10));// 9007199254740993n
        // // 上面代码中，由于有效数字超出了最大限度，Number.parseInt方法返回的结果是不精确的，而BigInt.parseInt方法正确返回了对应的 BigInt。
        // // 对于二进制数组，BigInt 新增了两个类型BigUint64Array和BigInt64Array，
        // // 这两种数据类型返回的都是64位 BigInt。DataView对象的实例方法DataView.prototype.getBigInt64()和DataView.prototype.getBigUint64() ，
        // // 返回的也是 BigInt。

        // 15.转换规则
        // 可以使用Boolean()、Number()和String()这三个方法，将 BigInt 可以转为布尔值、数值和字符串类型。
        // console.log(Boolean(0n));//false
        // console.log(Boolean(1n));//true
        // console.log(Number(1n));//1
        // console.log(String(1n));//"1"
        // // 上面代码中，注意最后一个例子，转为字符串时后缀n会消失。

        // // 另外，取反运算符（!）也可以将 BigInt 转为布尔值
        // console.log(!0n);//true
        // console.log(!1n);//false

        // 16.数学运算
        // !!!数学运算方面，BigInt 类型的+、-、*和**这四个二元运算符，与 Number 类型的行为一致。除法运算/会舍去小数部分，返回一个整数。
        console.log(9n / 5n);//1n
        // 几乎所有的数值运算符都可以用在 BigInt，但是有两个例外。
        // !!!不带符号的右移位运算符 >>>
        // !!!一元的求正运算符 +
        // 上面两个运算符用在 BigInt 会报错。前者是因为 >>> 运算符是不带符号的，
        // 但是 BigInt 总是带有符号的，导致该运算无意义，完全等同于右移运算符 >>。
        // 后者是因为一元运算符 + 在 asm.js 里面总是返回 Number 类型，为了不破坏 asm.js 就规定 + 1n会报错。

        // BigInt 不能与普通数值进行混合运算。
        console.log(1n + 1.3);//报错

        // 上面代码报错是因为无论返回的是 BigInt 或 Number，都会导致丢失精度信息。
        // 比如(2n ** 53n + 1n) + 0.5这个表达式，如果返回 BigInt 类型，0.5这个小数部分会丢失；
        // 如果返回 Number 类型，有效精度只能保持 53 位，导致精度下降。
        // 同样的原因，如果一个标准库函数的参数预期是 Number 类型，但是得到的是一个 BigInt，就会报错。

        // 错误的写法
        console.log(Math.sqrt(4n));
        //报错 Math.sqrt() 函数返回一个数的平方根
        // function calcHypotenuse(a, b) {
        //     return (Math.sqrt((a * a) + (b * b)));
        // }

        // console.log(calcHypotenuse(3, 4));// expected output: 5

        // console.log(calcHypotenuse(5, 12));// expected output: 13

        //正确写法
        console.log(Math.sqrt(Number(4n)));//2
        // 上面代码中，Math.sqrt的参数预期是 Number 类型，如果是 BigInt 就会报错，必须先用Number方法转一下类型，才能进行计算。
        // asm.js 里面，| 0跟在一个数值的后面会返回一个32位整数。根据不能与 Number 类型混合运算的规则，BigInt 如果与 | 0进行运算会报错
        console.log(1n | 0);//报错

        // 17.其他运算
        // BigInt 对应的布尔值，与 Number 类型一致，即0n会转为false，其他值转为true。
        if (0n) {
            console.log('if');

        } else {
            console.log('else');
        }
        // else

        // 上面代码中，0n对应false，所以会进入else子句。
        // 比较运算符（比如 >）和相等运算符（==）允许 BigInt 与其他类型的值混合计算，因为这样做不会损失精度。
        console.log(0n<1);//true
        console.log(0n<true);//true
        console.log(0n == 0)//true;
        console.log(0n == false);//true
        console.log(0n === 0);//false

        // BigInt 与字符串混合运算时，会先转为字符串，再进行运算。
        console.log(''+123n);//"123"
        
    </script>
</body>

</html>